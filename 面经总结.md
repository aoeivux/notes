# 面经总结(Java后端开发)

## Spring MVC执行流程

1. 用户发送请求至前端控制器**Dispatcher Servlet**
2. **Dispatcher Servlet**收到请求调用处理器映射器**Handler Mapping**
3. 处理器映射器根据**请求url**找到具体的**处理器**，生成处理器执行链**HandlerExecutionChain**(包括处理器对象和处理器拦截器)一并返回给**Dispatcher Servlet**
4. **Dispatcher Servlet**根据处理器**Handler**获取处理器适配器**HandlerAdapter**执行**Handler Adapter**处理一系列的操作，如：**参数封装**，**数据格式转换**，**数据验证**等操作，执行处理器**Handler Controller**，也叫页面控制器
5. Handler执行完成返回**ModelAndView**，**HandlerAdapter**将Handler执行结果ModelAndView返回到**Dispatcher Servlet**
6. **Dispatcher Servlet**将**ModelAndView**传给**View Reslover**视图解析器
7. **View Reslover**解析后返回具体**View**给**Dispatcher Servlet**
8. **Dispatcher Servlet**对**View**进行**渲染视图**（即将模型**数据model填充至视图中**）
9. **DispatcherServlet响应用户**



## Netty

netty架构设计， 高性能之处主要是来自**I/O模型**和**线程处理模型**，**前者**决定如何**收发数据**，**后者**决定如何**处理数据**。



### I/O模型



**I/O模型**包括，**阻塞模型** 和 **复用模型**



#### 阻塞模型

特点：

1. 每个请求都需要独立的线程完成数据 Read，业务处理，数据 Write 的完整操作问题。

2. 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。

3. 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪

费。

![image-20240323084252992](C:\Users\Aoeivuxt\AppData\Roaming\Typora\typora-user-images\image-20240323084252992.png)



#### 复用模型

特点：

1. **事件驱动**：Netty 是基于事件驱动的框架，它使用了 Reactor 模式。当某个事件发生时（例如新连接建立、数据读取、数据写入等），Netty 会触发相应的事件处理器来处理这些事件。
2. **单线程多路复用**：Netty 的复用模型基于单线程多路复用技术。这意味着它使用一个单独的线程来处理多个连接的 I/O 操作。通过选择适当的事件处理器，Netty 能够有效地管理多个连接，而不需要为每个连接创建一个独立的线程。
3. **Selector**：Netty 使用了 Java NIO 中的 Selector（选择器）来实现单线程多路复用。Selector 允许一个线程同时监视多个通道的就绪状态（例如读、写、连接等），并在通道就绪时进行相应的处理。
4. **高性能和低资源消耗**：Netty 的复用模型可以有效地利用系统资源，提供高性能的网络通信。相比于传统的阻塞 I/O 模型，Netty 在处理大量连接时能够更有效地利用线程和系统资源，减少了线程切换和资源消耗。
5. **支持并发处理**：Netty 的复用模型允许并发处理多个连接的 I/O 操作，而无需为每个连接创建一个独立的线程。这种并发处理方式可以提高系统的并发能力和响应性能。

![image-20240323084336964](C:\Users\Aoeivuxt\AppData\Roaming\Typora\typora-user-images\image-20240323084336964.png)



### 线程处理模型

#### 事件驱动模型

通常，我们设计一个事件处理模型的程序有两种思路：

1. 轮询方式：线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑；
2. 事件驱动方式：发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事

件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中观察

者模式的思路。



![image-20240323084820760](C:\Users\Aoeivuxt\AppData\Roaming\Typora\typora-user-images\image-20240323084820760.png)



主要包括 4 个基本组件：

1）事件队列（event queue）：接收事件的入口，存储待处理事件；

2）分发器（event mediator）：将不同的事件分发到不同的逻辑处理单元；

3）事件通道（event channel）：分发器与处理器之间的联系渠道；

4）事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作。



#### Reactor**线程模型**



​		Reactor 是反应堆的意思，Reactor 模型是指通过一个或多个输入同时传递给服务处理器的事件驱动处

理模式。

​		服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫

Dispatcher 模式，即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某线程)，是编写高性能

网络服务器的必备技术之一。

Reactor 模型中有 2 个关键组成：

​	1）Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO

事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；

​	2）Handlers：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官

员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。



![image-20240323084936145](C:\Users\Aoeivuxt\AppData\Roaming\Typora\typora-user-images\image-20240323084936145.png)



取决于 Reactor 的数量和 Hanndler 线程数量的不同，Reactor 模型有 3 个变种：

1）单 Reactor 单线程；

2）单 Reactor 多线程；

3）主从 Reactor 多线程。





### **核心类**

#### **Bootstrap/ServerBootstrap**

​		Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是**配置整个 Netty 程**

**序，串联各个组件**，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启

动引导类。



#### **Selector**

​		Netty 基于 Selector 对象实现 I/O 多路复用，**通过 Selector 一个线程可以监听多个连接的 Channel 事件**。

​		当向一个 Selector 中注册 Channel 后，S**elector 内部的机制就可以自动不断地查询(Select) 这些注册的**

**Channel 是否有已就绪的 I/O 事件**（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。



#### **Channel**

​		Netty 网络通信的组件，能够**用于执行网络 I/O 操作**。Channel 为用户提供：

​		1）当前网络连接的通道的状态（例如是否打开？是否已连接？）

​		2）网络连接的配置参数 （例如接收缓冲区大小）

​		3）提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。

​		4）调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。

​		5）支持关联 I/O 操作与对应的处理程序。

​		x不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。

​		常用的 Channel 类型：

​		**NioSocketChannel**，异步的客户端 TCP Socket 连接。

​		**NioServerSocketChannel**，异步的服务器端 TCP Socket 连接。

​		**NioDatagramChannel**，异步的 UDP 连接。

​		**NioSctpChannel**，异步的客户端 Sctp 连接。

​		**NioSctpServerChannel**，异步的 Sctp 服务器端连接。

上面这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。



#### **NioEventLoop/NioEventLoopGroup**

​		NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用

​		NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：

​		I/O 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由processSelectedKeys 方法触发。

​		非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。

​		两种任务的执行时间比由变量 ioRatio 控制，默认为 50，则表示允许非 IO 任务执行的时间与 IO 任务

的执行时间相等。

​		NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线

程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。



#### **ChannelHandler**

​		ChannelHandler 是一个接口，**处理 I/O 事件或拦截 I/O 操作**，并将其**转发到其 ChannelPipeline****(业务**

**处理链)中的下一个处理程序**。



#### **Future、**ChannelFuture

​		Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 **Future 和ChannelFutures**，他们可以注册一个监听，**当操作执行成功或失败时监听会自动触发注册的监听事件**。





### **开发步骤**

#### **服务端处理步骤**

1. 定义线程组
2. 定义启动服务类
3. 初始化事件处理器
4. 定义事件处理器的处理逻辑
5. 绑定端口、启动服务



#### **客户端处理步骤**

1. 定义线程组
2. 定义启动类
3. 初始化事件处理器
4. 定义事件处理器的处理逻辑
5. 绑定端口、启动客户端

Netty客户端和服务端的开发过程非常相似，但也有差异：

**相同点**：

1. 都是EventLoopGroup和NioEventLoopGroup。
2. 都有group，channel，handler（ChannelInitializer方法）

![image-20240323091040134](C:\Users\Aoeivuxt\AppData\Roaming\Typora\typora-user-images\image-20240323091040134.png)



#### **服务端代码**

```java
/**
 * 开启端口、接收数据
 */
public class Server {
	private int port;

	public Server(int port) {
		this.port = port;
	}

	public void run() throws Exception {
		// 1. 定义线程组
		// 定义接收请求的线程组
		EventLoopGroup boss = new NioEventLoopGroup();
		// 定义具体处理工作的线程组
		EventLoopGroup worker = new NioEventLoopGroup();
		// 2. 定义启动引导类
		ServerBootstrap bootstrap = new ServerBootstrap();
		// 3. 设置启动类的属性、绑定处理程序
		bootstrap.group(boss, worker)
				.channel(NioServerSocketChannel.class)
				.childHandler(new ChannelInitializer<SocketChannel>() {
					@Override
					protected void initChannel(SocketChannel socketChannel)
							throws Exception {
						// 注册处理程序
						socketChannel.pipeline().addLast(new ServerHandler());
					}
				})
				.option(ChannelOption.SO_BACKLOG, 128)
				.childOption(ChannelOption.SO_KEEPALIVE, true);
		// 4. 绑定端口
		try {
			ChannelFuture f = bootstrap.bind(port).sync();
			f.channel().closeFuture().sync();
		} finally {
			boss.shutdownGracefully();
			worker.shutdownGracefully();
		}
	}

	public static void main(String[] args) throws Exception {
		// 5. 启动服务
		new Server(10010).run();
	}
}

```



#### **客户端代码**

```java
public class Client {
	// 端口、ip
	private int port;
	private String ip;

	public Client(String ip, int port) {
		this.ip = ip;
		this.port = port;
	}

	/**
	 * 客户端的连接程序
	 */
	public void connect() {
		// 1. 定义线程池
		EventLoopGroup worker = new NioEventLoopGroup();
		// 2. 定义启动引导类
		Bootstrap bootstrap = new Bootstrap();
		// 3. 配置启动类的属性
		bootstrap.group(worker)
				.channel(NioSocketChannel.class)
				.option(ChannelOption.SO_KEEPALIVE, true)
				.handler(new ChannelInitializer<SocketChannel>() {
					@Override
					protected void initChannel(SocketChannel socketChannel)
							throws Exception {
						// 4. 注册处理程序
						socketChannel.pipeline().addLast(new ClientHandler());
					}
				});
		// 5. 连接服务器
		ChannelFuture future = bootstrap.connect(ip, port);
		future.channel().closeFuture();
	}

	public static void main(String[] args) {
		// 启动客户端
		new Client("127.0.0.1", 10010).connect();
	}
}
```

