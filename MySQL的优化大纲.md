# MySQL常见面经





## MySQL的事务的底层实现原理

MySQL里面的事务满足**ACID**原则，MySQL事务的原理就是InnoDB如何去保证**ACID**这样一个特性。

-  **A**，表示**原子性（Atomicity）**，也就是说，需要保证多个**DML**操作的原子性（DML也就是数据库操纵语言，比如``UPDATE、INSERT``），要么都成功，要么都失败。如果失败的话就意味着要对原本执行成功的数据进行**回滚**，所以**InnoDB**设计了一个**UNDO_LOG表**，在事务执行的过程中， 把修改之前的数据快照保存到**UNDO_LOG表**，一旦出现错误的话，就直接从**UNDO_LOG表**里面去读取数据，进行反向操作就可以了。

  

- **C**，表示**一致性（Consistency）**，也就是说，**数据的完整性约束**没有被破坏，更多是依赖于业务层的保障。数据库本身也提供了一些类似于主键的**唯一约束**、**字段长度和类型**的一些保障等。

  

- **I**，表示**隔离型（Isolation）**，也就是说，**多个并行事务**对**同一个数据**进行操作的时候，如何去避免多个事务的干扰，导致数据混乱的一个问题。而**InnoDB**里面实现了**SQL92标准**，并提供了**四种隔离级别**的实现。**InnoDB**默认采用的级别是**RR**，使用了**MVVC机制**解决了**脏读**和**不可重复读**的一个问题。使用了**行锁和表锁**解决了**幻读**的问题。

  - **RU（未提交读）**

  - **RC（已提交读）**

  - **RR（可重复读）**MySQL默认采用RR

  - **Serializable（串行化）**

  可能出现的问题

  ![image-20240430181726865](C:\Users\Aoeivuxt\Documents\notes\assets\image-20240430181726865.png)

  

- **D**，表示**持久性（Durability）**，也就是说，只要事务**提交成功**，那么对于这个数据结果的影响**一定是永久**的，不能因为**数据库宕机**或者其他原因导致**数据变更失效**。理论上来说，事务提交之后，直接把数据放到磁盘就Ok了。但是因为随即磁盘I/O的效率确实很低，所以**InnoDB**里面设计了**Buffer Pool缓冲区**来进行优化，也就是说**数据发生变更的时候**，**先更新内存缓冲区，然后在合适的时间内，再持久化到磁盘里面**。但是因为存在之前说的**数据库宕机**或者其他原因导致**数据变更失效**的问题，**InnoDB**又引入了**REDO_LOG表**这样一个文件，它存储了数据库变更之后的一个值。当我们通过事务进行数据更改的时候，除了**修改内存缓存区**里面的值以外，还会把**本次修改的值追加到REDO_LOG表**里面去，当事务提交的时候，直接把**REDO_LOG表**里面的数据刷新到磁盘里面去，进行持久化。这样如果当数据库出现宕机后，在MySQL重启后，直接读取执行**REDO_LOG表**里面的数据。



脏读（Dirty Read）、不可重复读（Non-repeatable Read）和幻读（Phantom Read）是数据库中的三种典型的并发问题，它们描述了不同情况下事务读取到的数据与预期不一致的情况。

1. **脏读（Dirty Read）**： **脏读是指一个事务读取了另一个事务未提交的数据**。当一个事务读取到另一个事务修改但尚未提交的数据时，如果该修改操作最终被回滚，那么读取到的数据实际上是无效的。脏读会导致读取到不一致的数据，可能会对事务产生误导性影响。
2. **不可重复读（Non-repeatable Read）**： **不可重复读是指在同一个事务内，两次读取相同的数据时，得到的结果不一致。**通常是由于在事务执行期间，其他事务修改了相同的数据，导致第二次读取得到的数据与第一次读取时不一致。不可重复读会破坏了事务的隔离性，使得事务无法读取到一致的数据。
3. **幻读（Phantom Read）**： **幻读是指在同一个事务内，两次查询同一个范围的数据，但第二次查询发现有新的数据插入，导致结果集中出现了“幻影”行**。幻读通常发生在使用了范围锁或者间隙锁的并发场景下，其他事务在事务执行期间插入了新的数据，导致第二次查询的结果集中出现了新插入的数据行，使得事务无法得到一致的结果。



## MVVC机制

### 数据库并发场景?

有三种, 分别为：

- **读-读**：不存在任何问题，也不需要并发控制
- **读-写**：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- **写-写**：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失



MySQL 中InnoDB中实现了事务（多版本并发控制MVCC+锁）， 其中通过MVCC解决隔离性问题。具体而言，**MVCC就是为了实现读-写冲突不加锁**，而这个读指的就是**快照读**, 而非当前读，当**前读实际上是一种加锁的操作，是悲观锁的实现**; 



### MVCC带来的好处是？

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题

在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

### 小结一下

总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：

- **MVCC + 悲观锁** MVCC解决读写冲突，悲观锁解决写写冲突
- **MVCC + 乐观锁** MVCC解决读写冲突，乐观锁解决写写冲突

这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题





## 行锁和表锁

数据库是怎样**隔离事务**的呢？这时候就牵连到了数据库锁。当插入数据时，就锁定表，这叫做**”锁表”**；当更新数据时，就锁定行，这叫做**”锁行”**。

MySQL中锁的分类，MySQL中的锁机制基本上都是采用的悲观锁来实现的。我们先来看一下”行锁”。

![image-20240430182912868](C:\Users\Aoeivuxt\Documents\notes\assets\image-20240430182912868.png)



### 行锁

顾名思义，行锁就是一锁锁一行或者多行记录，mysql的**行锁是基于索引加载的**，所以行锁是要加在索引响应的行上，即命中索引，如下图所示：

![image-20240430183111616](C:\Users\Aoeivuxt\Documents\notes\assets\image-20240430183111616.png)

**行锁的特征**：锁冲突概率低，并发性高，但是会有死锁的情况出现。



### 表锁

顾名思义，**表锁就是一锁锁一整张表**，**在表被锁定期间，其他事务不能对该表进行操作，必须等当前表的锁被释放后才能进行操作。**表锁响应的是**非索引字段**，即**全表扫描**，全表扫描时锁定整张表，sql语句可以通过执行计划看出扫描了多少条记录。



### 行锁触发条件

1. **显式加锁**：通过 `FOR UPDATE` 或 `LOCK IN SHARE MODE` 语句显式地对行进行加锁。
2. **更新操作**：当对某行数据执行更新操作时，MySQL 会自动对该行数据进行行锁定。
3. **插入操作**：当向包含唯一索引的表中插入数据时，MySQL 会对新插入的数据行进行行锁定，以保证唯一性。
4. **间隙锁（Gap Lock）**：当使用范围条件查询时（例如 WHERE 子句使用范围条件，而不是确定的值），MySQL 会对查询范围中的间隙（不存在的行）进行加锁，防止其他事务插入新数据或更新已有数据，从而保证了范围内数据的一致性。

### 表锁触发条件

1. **LOCK TABLES 语句**：通过 `LOCK TABLES` 语句对表进行显式加表锁。
2. **DDL 操作**：当对表进行诸如 ALTER TABLE、RENAME TABLE、TRUNCATE TABLE 等数据定义语言（DDL）操作时，MySQL 会自动对表进行排他锁定，防止其他事务对表进行并发操作。
3. **全局锁（Global Lock）**：当执行诸如 FLUSH TABLES WITH READ LOCK、FLUSH TABLES WITH READ、START TRANSACTION WITH CONSISTENT SNAPSHOT 等全局性操作时，MySQL 会对整个服务器上的所有表进行锁定。



## SQL92标准

SQL92 标准包括了许多重要的功能和特性，其中一些主要方面包括：

1. **数据查询语言（DQL）**：SQL92 定义了用于查询数据库中数据的语句，包括 **SELECT、FROM、WHERE** 等关键字。这些语句允许用户从数据库中检索、过滤和排序数据。
2. **数据操纵语言（DML）**：SQL92 定义了用于对数据库中数据进行插入、更新和删除操作的语句，包括 **INSERT、UPDATE 和 DELETE** 等关键字。这些语句允许用户对数据库中的数据进行修改。
3. **数据定义语言（DDL）**：SQL92 定义了用于创建、修改和删除数据库对象（如表、索引、视图等）的语句，包括 **CREATE、ALTER 和 DROP** 等关键字。这些语句允许用户管理数据库的结构。
4. **事务控制语言（TCL）**：SQL92 定义了用于控制事务的语句，包括 **COMMIT、ROLLBACK 和 SAVEPOINT** 等关键字。这些语句允许用户管理事务的提交和回滚。
5. **数据控制语言（DCL）**：SQL92 定义了用于控制数据库访问权限的语句，包括 **GRANT 和 REVOKE** 等关键字。这些语句允许数据库管理员管理用户对数据库的访问权限。
6. **数据类型**：SQL92 定义了用于表示数据类型的语法，包括整数、浮点数、字符、日期时间等各种类型。这些数据类型用于定义表中列的属性和约束。



## MySQL的存储索引



MySQL中的存储索引是一种特定类型的索引，用于提高查询性能和加速数据检索。MySQL支持多种类型的索引，包括B树索引、哈希索引、全文索引等，其中B树索引是最常见和默认的索引类型。下面是关于MySQL存储索引的一些介绍：

1. **B树索引**：B树索引是MySQL中最常见的索引类型之一，它基于B树（或B+树）数据结构构建。B树索引适用于范围查询、排序和连接操作。在B树索引中，每个叶子节点存储了索引列的实际值以及指向对应数据行的指针。
2. **唯一索引**：唯一索引是一种特殊的索引，要求索引列的值唯一。MySQL使用唯一索引来确保表中某列的值不重复。**唯一索引可以是单列索引，也可以是联合索引**。
3. **哈希索引**：MySQL也支持哈希索引，它基于哈希表数据结构构建。哈希索引适用于**等值查找**，但不支持范围查询或排序。因为哈希索引并不存储索引列的顺序，所以在处理范围查询或排序时效率较低。
4. **全文索引**：MySQL提供了全文索引功能，用于支持全文搜索。全文索引适用于在文本列上进行全文搜索操作，如匹配关键字、词组等。
5. **空间索引**：对于具有空间数据类型的列（如地理坐标），MySQL支持空间索引，用于支持空间数据的快速检索和分析。

优势：

- 加速查询操作：索引可以帮助MySQL快速定位符合查询条件的数据行，从而加速查询操作。
- 改善排序和连接性能：索引可以提高排序和连接操作的效率，尤其是对于大型数据集和复杂查询。
- 提高数据完整性：唯一索引可以确保表中的某列值的唯一性，保证数据的完整性。

需要注意的是，虽然索引可以提高查询性能，但过多或不合适的索引会增加数据库的维护成本，并且在写入操作时可能降低性能。因此，在设计和创建索引时需要权衡考虑。



## 数据结构算法

 **二叉树**---->**平衡二叉树**(红黑树)---->**B树**(平衡多路查找树)---->**B+树**(B树的进阶),也就是**MySQL的底层数据结构**



**二叉树**: 每个节点最多有两个子节，并遵循**左边小于右边**，数据随机性情况树杈越明显,缺点:随着数据的增多，树的结果会越高，数据查询的效率会变慢，如果数据是按顺序来排序依次进入的话，树的高度则会更明显

**红黑树**:虽通过自旋平衡，子节点自动分为2个，从而减少树的高度，当数据有序时，更明显，检索结果更佳，数据量越大树也会越高

**b树**：b-tree的出现，可以解决树的高度的问题，他不在限制一个父节点中只有两个子节点，而是允许M个子节点(M>2)。不仅如此，B树的一个节点可以存储多个元素，相交于二叉树的结构又将整体的树高度降低了

**B+树**：b+tree是b树的一种升级优化，更适合做存储索引结构，在B+tree中，**非叶子节点上仅存储key**，不存储数据，**所有的数据均存储在叶子的节点上面**，并且是按照顺序来排序的，此外在B+tree中各个叶子节点是双向连接的。



## 什么是MySQL的回表?
MySQL中的索引有很多中不同的分类方式，可以按照数据结构分，可以按照逻辑角度分，也可以按照物理存储分类，其中，按照物理存储方式，可以分为聚簇索引和非聚簇索引。

我们日常所说的主键索引，其实就是聚簇索引(ClusteredIndex);主键索引之外，其他的都称之为非主键索引,非主键索引也被称为二级索引(SecondaryIndex)，或者叫作辅助索引。

对于**主键索引和非主键索引**，使用的数据结构都是 B+Tree，**唯一的区别在于叶子结点中存储的内容不同**:
**主键索引的叶子结点存储的是一行完整的数据**

**非主键索引的叶子结点存储的则是主键值**。这就是两者最大的区别。

所以，当我们需要查询的时候:
如果是通过主键索引来查询数据，例如 ``select * from user where id=100``，那么此时只需要搜索主键索引1.的 B+Tree 就可以找到数据。

如果是通过非主键索引（二级索引）来查询数据，例如``select * from user where username='javaboy'``，那么此时需要先搜索 username 这一列索引的 B+Tree，搜索完成后得到主键的值，然后再去搜索主键索引的 B+Tree(根据搜索得到的主键值进行回表搜索该主键值对应的**username**).就可以获取到一行完整的数据。

对于第二种查询方式而言，**一共搜索了两棵 B+Tree，第一次搜索 B+Tree 拿到主键值后再去搜索主键索引的B+Tree，这个过程就是所谓的回表**。

从上面的分析中我们也能看出，通过**非主键索引查询要扫描两棵 B+Tree**，而通过主键索引查询只需要扫描一棵B+Tree，所以如果条件允许，还是建议在查询中**优先选择通过主键索引进行搜索**。



## 聚集索引和非聚集索引的区别？

按物理存储分类：innoDB属于聚集索引，MyISAM属于非聚集索引

**聚集索引**:它的**子叶同时存储索引和数据**（通常更快的性能）

**非聚集索引**：它的**子叶只存储索引和指针**，需要**通过指针来查找具体的数据**

效率：**聚集索引更快**



## 索引分类

**二级索引**：**所有非主键索引都称为二级索引**，**并且二级索引为非聚集索引**，**查找数据需要进行回表**（这里的回表就是先根据该二级索引字段比如``username``找到该二级索引对应的主键值，进行回表，在主键索引中找到该主键对应的二级索引字段``username``）



**覆盖索引**: 需要查询的字段都在索列中的情况称为覆盖索引，索引列覆盖了查询字段的意思



**索引下推**：是mysql5.6之后针对扫描二级索引的一项改进，**用来在范围查询是减少回表的次数，将需要回表的查询一次性完成**



**单列索引**：只有一个索引字段(name)



**联合索引**：多个索引字段(name,age,heigt)，联合索引需要遵循**最左前缀原则**，以最左边为起点任意连续的索引都能匹配上,因为没有第一列的话，直接访问第二列，那么第二列肯定是无序的，直接访问后面的列就用不到索引了.

联合索引注意点：针对最左前缀原则，**带头大哥不能死，中间兄弟不能断**



## 单列索引和联合索引分别在什么场景创建，优势是什么？

### 联合索引的优势

1.减少开销:

建立一个联合索引，实际上相当于创建了多个索引``((a), (a,b), (a,b,c))``,每单独建一个索引，都会增加写操作的开销和磁盘的开销，**对于大量的数据，使用联合查询会大大减少开销**

2.覆盖索引:

``select a,b,c from table where a ='xx' and b='xxx'``

那么mysql可以直接遍历索引取得数据，而无需回表，减少了很多的io操作，减少**io**操作，特别是随机io是dba主要的优化机制

3.效率高：

索引列多，通过联合索引筛选出的数据越少，比如有100万条的数据表，有如下sql：

``select col1,col2,col3 from table where col1='1' and colw='2' and col2='3'``

如果是单列的话需要查找三次



### **单列索引**适用于以下场景

1. **单列条件过滤**：当查询中只包含对单个列的条件过滤时，单列索引可以提高查询性能。
2. **单列排序**：当需要对单个列进行排序操作时，单列索引可以加速排序操作。
3. **单列连接**：当连接查询中的连接条件只涉及到单个列时，单列索引可以提高连接操作的速度。

优势：

- 索引的维护成本相对较低，因为只需要维护单个列的索引结构。
- 更适合于单一列的查询优化。

### **联合索引**适用于以下场景

1. **多列条件过滤**：当查询中包含多个列的条件过滤时，联合索引可以提高查询性能。这些条件可以是多个列的组合条件，而不仅限于单个列。
2. **多列排序**：当查询中需要对多个列进行排序操作时，联合索引可以加速排序操作。
3. **多列连接**：当连接查询中的连接条件涉及到多个列时，联合索引可以提高连接操作的速度。

优势：

- 可以更好地支持复合条件查询和排序操作。
- 在包含多个列的查询或排序中，相比于多个单列索引，使用联合索引通常能够减少索引的数量，从而减少了数据库的存储空间和维护成本。

总的来说，单列索引适用于单个列的查询和排序，而联合索引则适用于多个列的查询和排序，它们各有优势，需要根据具体的业务需求和查询模式来选择合适的索引类型。



## 索引的优点和缺点

### 索引的优点

1.提高检索效率

2.降低排序成本，索引对应的字段已经有一个自动排序·功能的，**默认是升序asc**



### 索引的缺点

1.创建索引和维护索引需要耗费时间，这种时间会随着数据增加而增加

2.索引需要占用无聊空间，数据量越大，占用越多

3.会降低表增删改的效率，因为**每次增删改索引，都需要进行动态维护**



## SQL索引优化

1.创建索引减少扫描量·

2.调整索引减少计算量

3.索引覆盖(减少不必访问的列，避免回表查询)

4.干预执行计划

5.sql改写



如果索引失效，需要排查：

手动添加索引：force index(idx_name_age_position)

1.如果索引了多列，要遵循**最左前缀原则**，指的是查询从最左边开始并且不跳过索引中的列。（**带头大哥不能死，中间兄弟不能断**）

2.不在索引列上做任何操作(计算，函数，(自动or手动)， 类型转换),会导致索引失效而造成全表扫描

3.索引引擎不能使用索引中范围条件中右边的列,范围查询会使得字段无序，造成部分索引失效

4.尽量使用覆盖索引(只访问索引的查询(索引列包含列),减少select * 语句，覆盖索引不写*

5.不等空值还有or，索引失效要少用

6.like百分写在最右

7.字符串不加单引号索引会失效

8.范围查询优化



trace工具用法:(跟踪查询过程和结果)

第一阶段:sql准备阶段，格式化sql

第二阶段:sql优化阶段

第三阶段:预估表的访问成本 -->对全表扫描情况行数，查询成本,再查询索引的成本，再根据估值分决定用索引还是全盘扫描



sql最佳实践：

1.避免使用**select ***

1).会增加查询解析器的成本

2).不走覆盖索引会产生大量的回表查询

3).浪费cpu和内存资源



2.小表驱动大表：

用数据量少的表用索引和条件大表进行数据筛选，从而减少数据计算量，提高查询效率



3.用连接查询代替子查询:

1).子查询需要执行两次数据库查询，一次是外部，一次是嵌套子查询。因此，使用连接查询可以减少数据库查询的次数，提高查询的效率

2).连接查询可以更好的利用数据库索引，提高查询性能。子查询通常会使用临时表或内存表，而连接查询可以直接利用表上的索引。这意味着连接查询可以更快的访问表中的数据，减少查询的资源消耗

3).对于大型数据集，使用连接查询通常比使用子查询更高效，子查询通常需要扫描整个表，而连接查询可以利用索引加速读取操作